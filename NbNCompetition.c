#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    AutoProgram,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  BallInTrigger,  sensorTouch)
#pragma config(Sensor, dgtl2,  Overflow,       sensorTouch)
#pragma config(Sensor, dgtl3,  LCDin,          sensorDigitalIn)
#pragma config(Sensor, dgtl4,  LCDout,         sensorDigitalOut)
#pragma config(Sensor, dgtl8,  LiftTop,        sensorTouch)
#pragma config(Sensor, dgtl9,  LiftBottom,     sensorTouch)
#pragma config(Sensor, I2C_1,  TriggerAngleIME, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  FlywheelSpeedIME, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  CanopyAngleIME, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Lift1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           Drive_L,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Drive_R,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           Motor_FW1,     tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port5,           Motor_FW2,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Motor_FW3,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           Canopy_motor,  tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port8,           Trigger_motor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           BallPicker,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          Lift2,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define FLYWHEEL_SPEED_DELTA_STEP 25
#define FLYWHEEL_MAX_SPEED 2900
#define FLYWHEEL_MIN_SPEED 1000
#define FLYWHEEL_INIT_SPEED 2200
#define FLYWHEEL_MAX_RPM_DELTA 50       //can shoot if actual RPM within this many units of set RPM

#define FLYWHEEL_MAX_Ki_CONTRIBUTION 0.3 // Maximum amount of contribution from Ki for launcher (between 0 and 1)

#define BUTTON_DEBOUNCE_TIME 100 // milliseconds

#define CANOPY_INCREMENT 5

#define CANOPY_FRONT -80
#define RPM_FRONT 1800

#define CANOPY_MIDDLE 0
#define RPM_MIDDLE 2075  // was 2125

#define CANOPY_BACK 0
#define RPM_BACK 2440 // was 2500

#define CHANGE_DELTA 25

#define RPM_Kp 0.0035
#define RPM_Kd 0.0015 //was 0.0015
#define RPM_Ki 0.00005

#define WAITING_SHOOT_TIME_OUT	1000

#define NUM_PIDS 2
#define PID_CANOPY 0
#define PID_TRIGGER 1
struct PIDInfo {
	int desired_position;
	int motor_index;
	float previous_error;
	float cumulative_error;
}

float start_speed;
float start_drive = 0.47;

int last_canopy_angle;

// Global Variables that control the Ball Picker
int feeder_state = 0; // 0 is off, 1 is on
int feeder_direction = 1; // 1 is pick-up-balls, -1 is drop balls
int autoload_mode = 0;
#define AUTOLOAD_STATE_RELOAD 0
#define AUTOLOAD_STATE_OVERFLOW_REVERSE 1
#define AUTOLOAD_STATE_OVERFLOW 2
int autoload_state = AUTOLOAD_STATE_RELOAD;
#define AUTOLOAD_REVERSE_TIME 250 // reverse time after overlow in ms
unsigned int autoload_reverse_timeout;

int debug_canopy_value;
int debug_trigger_value;

int auto_shoot_mode = 0;


/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*                        Copyright (c) James Pearman                          */
/*                                   2015                                      */
/*                            All Rights Reserved                              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Module:     flywheel.c                                                   */
/*    Author:     James Pearman                                                */
/*    Created:    28 June 2015                                                 */
/*                                                                             */
/*    Revisions:                                                               */
/*                V1.00  28 June 2015 - Initial release                        */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    The author is supplying this software for use with the VEX cortex        */
/*    control system. This file can be freely distributed and teams are        */
/*    authorized to freely use this program , however, it is requested that    */
/*    improvements or additions be shared with the Vex community via the vex   */
/*    forum.  Please acknowledge the work of the authors when appropriate.     */
/*    Thanks.                                                                  */
/*                                                                             */
/*    Licensed under the Apache License, Version 2.0 (the "License");          */
/*    you may not use this file except in compliance with the License.         */
/*    You may obtain a copy of the License at                                  */
/*                                                                             */
/*      http://www.apache.org/licenses/LICENSE-2.0                             */
/*                                                                             */
/*    Unless required by applicable law or agreed to in writing, software      */
/*    distributed under the License is distributed on an "AS IS" BASIS,        */
/*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*    See the License for the specific language governing permissions and      */
/*    limitations under the License.                                           */
/*                                                                             */
/*    The author can be contacted on the vex forums as jpearman                */
/*    or electronic mail using jbpearman_at_mac_dot_com                        */
/*    Mentor for team 8888 RoboLancers, Pasadena CA.                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    An example of flywheel/shooter velocity control using the TBH algorithm  */
/*    Test system uses three motors with 25:2 gearing to the flywheel.         */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              25

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          261.333

// Structure to gather all the flywheel ralated data
typedef struct _fw_controller {
	long            counter;                ///< loop counter used for debug

	// encoder tick per revolution
	float           ticks_per_rev;          ///< encoder ticks per revolution

	// Encoder
	long            e_current;              ///< current encoder count
	long            e_last;                 ///< current encoder count

	// velocity measurement
	float           v_current;              ///< current velocity in rpm
	long            v_time;                 ///< Time of last velocity calculation

	// TBH control algorithm variables
	long            target;                 ///< target velocity
	long            current;                ///< current velocity
	long            last;                   ///< last velocity
	float           error;                  ///< error between actual and target velocities
	float           last_error;             ///< error last time update called
	float           gain;                   ///< gain
	float           drive;                  ///< final drive out of TBH (0.0 to 1.0)
	float           drive_at_zero;          ///< drive at last zero crossing
	long            first_cross;            ///< flag indicating first zero crossing
	float           drive_approx;           ///< estimated open loop drive

	// final motor drive
	long            motor_drive;            ///< final motor control value
	long            previous_motor_drive;

	// fields for PID version of speed control
	float						error_previous;
	float						error_integral;
} fw_controller;

// Make the controller global for easy debugging
static  fw_controller   flywheel;

/*-----------------------------------------------------------------------------*/
/** @brief      Set the flywheen motors                                        */
/** @param[in]  value motor control value                                      */
/*-----------------------------------------------------------------------------*/
void
FwMotorSet( int value )
{
	motor[ Motor_FW1 ] = value;
	motor[ Motor_FW2 ] = value;
	motor[ Motor_FW3 ] = value;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Get the flywheen motor encoder count                           */
/*-----------------------------------------------------------------------------*/
long
FwMotorEncoderGet()
{
	return( nMotorEncoder[ Motor_FW1 ] );
}

/*-----------------------------------------------------------------------------*/
/** @brief      Set the controller position                                    */
/** @param[in]  fw pointer to flywheel controller structure                    */
/** @param[in]  desired velocity                                               */
/** @param[in]  predicted_drive estimated open loop motor drive                */
/*-----------------------------------------------------------------------------*/
void
FwVelocitySet( fw_controller *fw, int velocity, float predicted_drive )
{
	// set target velocity (motor rpm)
	fw->target        = velocity;

	// Set error so zero crossing is correctly detected
	fw->error         = fw->target - fw->current;
	fw->last_error    = fw->error;

	// Set predicted open loop drive value
	fw->drive_approx  = predicted_drive;
	// Set flag to detect first zero crossing
	fw->first_cross   = 1;
	// clear tbh variable
	fw->drive_at_zero = 0;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Calculate the current flywheel motor velocity                  */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwCalculateSpeed( fw_controller *fw )
{
	int     delta_ms;
	int     delta_enc;

	// Added by SK to smooth velocity calculations
	float alpha = 0.2;
	//float alpha = 1;

	// Get current encoder value
	fw->e_current = FwMotorEncoderGet();

	// This is just used so we don't need to know how often we are called
	// how many mS since we were last here
	delta_ms   = nSysTime - fw->v_time;
	fw->v_time = nSysTime;

	// Change in encoder count
	delta_enc = (fw->e_current - fw->e_last);

	// save last position
	fw->e_last = fw->e_current;

	// Calculate velocity in rpm
	fw->v_current = fw->v_current * (1-alpha) + (1000.0 / delta_ms) * delta_enc * 60.0 / fw->ticks_per_rev * 11.66666 * alpha; //SK HACK




	//writeDebugStreamLine("Current Speed is %f", fw->v_current);
}

/*-----------------------------------------------------------------------------*/
/** @brief      Update the velocity tbh controller variables                   */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwControlUpdateVelocityTbh( fw_controller *fw )
{
	// calculate error in velocity
	// target is desired velocity
	// current is measured velocity
	fw->error = fw->target - fw->current;

	// Use Kp as gain
	fw->drive =  fw->drive + (fw->error * fw->gain);


	// Clip - we are only going forwards
	if( fw->drive > 1 )
		fw->drive = 1;
	if( fw->drive < 0 )
		fw->drive = 0;

	// Check for zero crossing
	if( sgn(fw->error) != sgn(fw->last_error) ) {
		// First zero crossing after a new set velocity command
		if( fw->first_cross ) {
			// Set drive to the open loop approximation
			fw->drive = fw->drive_approx;
			fw->first_cross = 0;
		}
		else
			fw->drive = 0.5 * ( fw->drive + fw->drive_at_zero );

		// Save this drive value in the "tbh" variable
		fw->drive_at_zero = fw->drive;
	}

	// Save last error
	fw->last_error = fw->error;
}

int rpm_loop_count = 0;
void
FwControlUpdateVelocityPID( fw_controller *fw )
{
	float error_derivative;

	// calculate error in velocity
	// target is desired velocity
	// current is measured velocity
	fw->error = fw->target - fw->current;

	error_derivative = fw->error - fw->error_previous;
	fw->error_previous = fw->error;
	fw->error_integral = fw->error_integral + fw->error;

	// kludge to limit Integral term
	float Ki_term;
	Ki_term = fw->error_integral*RPM_Ki;
	if (abs(fw->error_integral*RPM_Ki) > FLYWHEEL_MAX_Ki_CONTRIBUTION) {
		fw->error_integral = sgn(fw->error_integral) * FLYWHEEL_MAX_Ki_CONTRIBUTION/RPM_Ki;
	}

	// Use Kp as gain
	fw->drive = fw->error*RPM_Kp + error_derivative*RPM_Kd + fw->error_integral * RPM_Ki;

	rpm_loop_count++;

#ifdef DEBUG_RPM_PID
	if (rpm_loop_count % 40 == 0) {
		writeDebugStreamLine("Error: %f Drive: %f P: %f D: %f", fw->error, fw->drive, fw->error*RPM_Kp, error_derivative*RPM_Kd);
	}
#endif // DEBUG_RPM_PID

	if (fw->drive < 0) {
		fw->drive = 0;
	}
	if (fw->drive > 1) {
		fw->drive = 1;
	}
}

task
FwControlTask()
{
	fw_controller *fw = &flywheel;

	// Set the gain
	// fw->gain = 0.000055;
	// fw->gain = 0.0008;
	// Setting the gain back down to a lower value. SS 11/28

	fw->gain = 0.0002;

	// We are using Speed geared motors
	// Set the encoder ticks per revolution
	fw->ticks_per_rev = MOTOR_TPR_393R;

	// PID initialization
	fw->drive = 0.0;
	fw->error_previous = 0;
	fw->error_integral = 0;
	fw->previous_motor_drive = 0;

	while(1)
	{
		// debug counter
		fw->counter++;

		// Calculate velocity
		FwCalculateSpeed( fw );

		// Set current speed for the tbh calculation code
		fw->current = fw->v_current;

		// Do the velocity TBH calculations
		//FwControlUpdateVelocityTbh( fw ) ;

		// PID control
		FwControlUpdateVelocityPID(fw);

		// Scale drive into the range the motors need
		fw->motor_drive  = (fw->drive * FW_MAX_POWER) + 0.5;


		// Final Limit of motor values - don't really need this
		if( fw->motor_drive >  127 ) fw->motor_drive =  127;
		if( fw->motor_drive < 0 ) fw->motor_drive = 0;

		// Code to limit delta
		if(abs(fw->motor_drive - fw->previous_motor_drive) > 3){
			if (fw->motor_drive > fw->previous_motor_drive) {
				fw->motor_drive = fw->previous_motor_drive + 3;
				} else {
				fw->motor_drive = fw->previous_motor_drive - 3;
			}
		}

		// and finally set the motor control value
		FwMotorSet( fw->motor_drive );
		fw->previous_motor_drive = fw->motor_drive;

		// Run at somewhere between 20 and 50mS
		//wait1Msec( FW_LOOP_SPEED );
		wait1Msec( 10 );
	}
}


int wheelSpeedError(fw_controller *fw)
{
	return fw->target - fw->current;
}

#define TRIGGER_POSITION_MAX 390
#define TRIGGER_POSITION_MIN 0

#define CANOPY_POSITION_MAX 0
#define CANOPY_POSITION_MIN -285

#define TRIGGER_STATE_READY 0
#define TRIGGER_STATE_SHOOT_BACKOFF 1
#define TRIGGER_STATE_SHOOTING 2
#define TRIGGER_STATE_RELOADING 3
#define TRIGGER_STATE_WAITING 4

#define TRIGGER_LOADING_MIN_DIST_FROM_CANOPY 160 // Canopy value + 160 is the load position
#define TRIGGER_SHOOTING_MIN_DIST_FROM_CANOPY 315 // was 305 Canopy value + 320 is the trigger position

#define TRIGGER_TIMEOUT 750

#define TRIGGER_LOADING_OPTIMAL_VALUE 50

#define TRIGGER_TIME_RUN_BALL_PICKER_BACWARDS_WHILE_SHOOTING 250 // in ms how long to run backwards to prevent ball interference

int shoot_request = 0;

//#define CANOPY_TRIGGER_MIN_DELTA 20 // The Trigger Servo needs to never come less than this number of ticks
// from the current Canopy Value

#define TRIGGER_REQ_SHOOT  0
#define TRIGGER_REQ_RELOAD 1


#define RELOAD_WAIT_TIME 500 // how long to wait for ball during reloading before moving to READY state

int trigger_position_desired = 0;
unsigned int next_auto_shoot_time;

int number_auto_balls_shot = 0;

float Trigger_Kp = 1.2; // was 1.8

float Trigger_Kd = 2;
float Trigger_Ki = 0.2;

void zero_position_set() {
	int new_trigger_encoder_value, new_canopy_encoder_value;
	int old_trigger_encoder_value = nMotorEncoder[Trigger_motor];
	int old_canopy_encoder_value = nMotorEncoder[Canopy_motor];
	int canopy_not_done = 1;
	int trigger_not_done = 1;

	// Start Trigger and Canopy moving towards their start values
	motor[Trigger_motor] = -35;
	motor[Canopy_motor] = +35;

	while (canopy_not_done || trigger_not_done) {
		wait1Msec(100); // wait in beginning since we just read the IME value and need time for it to change if it isn't at initial pos.
		if (trigger_not_done) {
			new_trigger_encoder_value = nMotorEncoder[Trigger_motor];
			if ((new_trigger_encoder_value - old_trigger_encoder_value) == 0) { // If value hasn't changed then we're done
				motor[Trigger_motor] = 0;
				trigger_not_done = 0;
				} else {
				old_trigger_encoder_value = new_trigger_encoder_value;
			}
		}
		if (canopy_not_done) {
			new_canopy_encoder_value = nMotorEncoder[Canopy_motor];
			if ((new_canopy_encoder_value - old_canopy_encoder_value) == 0) {
				motor[Canopy_motor] = 0;
				canopy_not_done = 0;
				} else {
				old_canopy_encoder_value = new_canopy_encoder_value;
			}
		}
	}
	wait1Msec(200);
	nMotorEncoder[Trigger_motor] = 0; // Set new zero Trigger position
	nMotorEncoder[Canopy_motor] = 0; // Set new zero Canopy position

}

struct PIDInfo PIDs[NUM_PIDS];
void PIDInit () {

	zero_position_set();
	PIDs[PID_CANOPY].desired_position = CANOPY_POSITION_MAX;
	PIDs[PID_CANOPY].motor_index = Canopy_motor;
	PIDs[PID_CANOPY].previous_error = 0;
	PIDs[PID_CANOPY].cumulative_error = 0;

	PIDs[PID_TRIGGER].desired_position = TRIGGER_POSITION_MIN;
	PIDs[PID_TRIGGER].motor_index = Trigger_motor;
	PIDs[PID_TRIGGER].previous_error = 0;
	PIDs[PID_TRIGGER].cumulative_error = 0;
}


#define MAX_CUMULATIVE_ERROR 1000
task CanopyTriggerPID()
{
	int current_position, i;
	float motor_power, error;

	PIDInit();

	while(1) {
		debug_canopy_value = nMotorEncoder[Canopy_motor];
		debug_trigger_value = nMotorEncoder[Trigger_motor];

		for (i = 0; i < NUM_PIDS; i++) {
			// Tries to get to position requested
			current_position = nMotorEncoder[PIDs[i].motor_index];
			error = ( PIDs[i].desired_position - current_position);
			PIDs[i].cumulative_error += error;
			if (abs(PIDs[i].cumulative_error) > MAX_CUMULATIVE_ERROR) {
				PIDs[i].cumulative_error = sgn(error) * MAX_CUMULATIVE_ERROR;
			}

			motor_power = Trigger_Kp * error + Trigger_Kd * (error - PIDs[i].previous_error) + Trigger_Ki * PIDs[i].cumulative_error;
			PIDs[i].previous_error = error;

			if (motor_power > 127) motor_power = 127;
			if (motor_power < -127) motor_power = -127;

			motor[PIDs[i].motor_index] = motor_power;
		}

		wait1Msec(25);
	}
}

void set_canopy_position(int target) {
	if (target > CANOPY_POSITION_MAX) target = CANOPY_POSITION_MAX;
	if (target < CANOPY_POSITION_MIN) target = CANOPY_POSITION_MIN;
	PIDs[PID_CANOPY].desired_position = target;
}

void set_trigger_position(int target) {
	if (target > TRIGGER_POSITION_MAX) target = TRIGGER_POSITION_MAX;
	if (target < TRIGGER_POSITION_MIN) target = TRIGGER_POSITION_MIN;
	PIDs[PID_TRIGGER].desired_position = target;
}

int updated_trigger_position_desired;
int trigger_position_actual;

// This function sets the trigger position (shoot or reload) and checks to see if that position has been reached
int trigger_set_and_check(int trigger_request) {
	//int trigger_position_actual;
	//int updated_trigger_position_desired;
	int retval = 0; // return value

	switch (trigger_request) {
	case TRIGGER_REQ_SHOOT:

		updated_trigger_position_desired = nMotorEncoder[Canopy_motor] + TRIGGER_SHOOTING_MIN_DIST_FROM_CANOPY;
		// 11/19/2015 Change to make trigger move more if angle is < -75
		if (PIDs[PID_CANOPY].desired_position < -65) {
			updated_trigger_position_desired += 50;
		}
		trigger_position_actual = nMotorEncoder[Trigger_motor];
		if (trigger_position_actual >= updated_trigger_position_desired) {
			// We've already reached our desired value
			retval = 1;
		}
		break;

	case TRIGGER_REQ_RELOAD:
		// Trigger should be in the reload position
		updated_trigger_position_desired = nMotorEncoder[Canopy_motor] + TRIGGER_LOADING_MIN_DIST_FROM_CANOPY;
		if (updated_trigger_position_desired > TRIGGER_LOADING_OPTIMAL_VALUE) {
			updated_trigger_position_desired = TRIGGER_LOADING_OPTIMAL_VALUE;
		}
		trigger_position_actual = nMotorEncoder[Trigger_motor];
		if (trigger_position_actual <= updated_trigger_position_desired) {
			// we have reached our desired position
			retval = 1;
		}
		break;
	}

	if (updated_trigger_position_desired != trigger_position_desired) {
		// Only write to the trigger servo if the desired position has changed
		set_trigger_position(updated_trigger_position_desired);
		trigger_position_desired = updated_trigger_position_desired;
	}
	return retval; // whether or not we have reached our desired position
}

int disable_ball_picker = 0;

task trigger_management()
// This task manages the trigger Servo and does things based on the current_trigger_state
{

	int shoot_time_out_enabled = 0;
	unsigned int shoot_cancel_time = 0;
	int trigger_task_loop_time = 25; // ms

	int current_trigger_state = TRIGGER_STATE_WAITING;
	unsigned int trigger_timeout_time;
	unsigned int shooting_run_loader_backwards_timeout_time;
	int fr1;

	while(1)
	{
		switch(current_trigger_state) {
		case TRIGGER_STATE_READY:

			fr1 = 1; // shot failed-to-shoot reason 1
			// Ball is loaded, check to see if shooting requested
			if ((shoot_request == 1 || (auto_shoot_mode == 1 && nSysTime >= next_auto_shoot_time))
				&& (fr1 = (abs(wheelSpeedError(&flywheel)) <= FLYWHEEL_MAX_RPM_DELTA))) {
				if (auto_shoot_mode) {
					next_auto_shoot_time = nSysTime /*+ 1500*/;
				}

				// Move trigger up to shoot

				disable_ball_picker = 1;
				motor[BallPicker] = -127;
				current_trigger_state = TRIGGER_STATE_SHOOT_BACKOFF;
				trigger_timeout_time = nSysTime + TRIGGER_TIMEOUT;
				shooting_run_loader_backwards_timeout_time = nSysTime + TRIGGER_TIME_RUN_BALL_PICKER_BACWARDS_WHILE_SHOOTING;
				trigger_set_and_check(TRIGGER_REQ_RELOAD);
			}
			else {
				trigger_set_and_check(TRIGGER_REQ_RELOAD);
				// DEBUG START
				if (shoot_request) {
					if (!fr1) {
						writeDebugStreamLine("Didn't shoot due to RPM; Error: %f", wheelSpeedError(&flywheel));
					}
					else {
						writeDebugStreamLine("Didn't shoot due to unknown reason");
					}
				}
				// DEBUG END
			}
			break;

		case TRIGGER_STATE_SHOOT_BACKOFF:
			if (nSysTime > shooting_run_loader_backwards_timeout_time) {
				motor[BallPicker] = 0;
				disable_ball_picker = 0;
				current_trigger_state = TRIGGER_STATE_SHOOTING;
				trigger_set_and_check(TRIGGER_REQ_SHOOT);
			}
			else {
				trigger_set_and_check(TRIGGER_REQ_RELOAD);
			}
			break;
		case TRIGGER_STATE_SHOOTING:

			if ( trigger_set_and_check(TRIGGER_REQ_SHOOT) || nSysTime > trigger_timeout_time) { // returns 1 if reached desired shooting position
				if (nSysTime > trigger_timeout_time) {
					writeDebugStreamLine("Shoot: Timeout");
					disable_ball_picker = 0;
				}
				else {
					writeDebugStreamLine("Shoot: Success");
					shoot_request = 0; // Since we have fired the ball, reset this request to 0
					// DEBUG START
					writeDebugStreamLine("RPM: %d", flywheel.v_current);
					// DEBUG END
					if (auto_shoot_mode) {
						number_auto_balls_shot++;
					}
				}
				current_trigger_state = TRIGGER_STATE_RELOADING;
				trigger_set_and_check(TRIGGER_REQ_RELOAD);
				disable_ball_picker = 0;


			}
			break;
		case TRIGGER_STATE_RELOADING:
			if (trigger_set_and_check(TRIGGER_REQ_RELOAD)) { // returns 1 if reached desired reloading position
				current_trigger_state = TRIGGER_STATE_WAITING;
			}
			break;
		case TRIGGER_STATE_WAITING:

			// wait till a new ball drops into the trigger's cup
			trigger_set_and_check(TRIGGER_REQ_RELOAD); // this is done in case the canopy moved
			if (SensorValue[BallInTrigger]) {
				current_trigger_state = TRIGGER_STATE_READY;
				shoot_time_out_enabled = 0;
			}
			else if (shoot_request == 1) {
				if(shoot_time_out_enabled) {
					if(nSysTime > shoot_cancel_time) {
						shoot_request = 0;
						shoot_time_out_enabled = 0;
					}
				}
				else {
					shoot_cancel_time = nSysTime + WAITING_SHOOT_TIME_OUT;
					shoot_time_out_enabled = 1;
				}
			}
			break;
		}

		// BallPicker is controlled from the trigger control task as well
		if (!disable_ball_picker) { // Momentarily running backwards, so don't do anything
			if (autoload_mode) {

				switch (autoload_state) {
				case AUTOLOAD_STATE_RELOAD:
					if (SensorValue[BallInTrigger] && SensorValue[Overflow]) {
						autoload_state = AUTOLOAD_STATE_OVERFLOW_REVERSE;
						autoload_reverse_timeout = nSysTime + AUTOLOAD_REVERSE_TIME;
						motor[BallPicker] = -127;
						} else {
						motor[BallPicker] = 127;
					}
					break;
				case AUTOLOAD_STATE_OVERFLOW_REVERSE:
					if (SensorValue[BallInTrigger] == 0) { // Trigger is empty, restart Ballpicker
						autoload_state = AUTOLOAD_STATE_RELOAD;
						motor[BallPicker] = 127;
					}
					else if (nSysTime >= autoload_reverse_timeout) {
						autoload_state = AUTOLOAD_STATE_OVERFLOW;
						motor[BallPicker] = 0;
					}
					break;
				case AUTOLOAD_STATE_OVERFLOW:
					if (SensorValue[BallInTrigger] == 0) {
						autoload_state = AUTOLOAD_STATE_RELOAD;
						motor[BallPicker] = 127;
					}
					break;
				}
			}
			else { // Not in autoload mode
				if (feeder_state) {
					if (feeder_direction == 1) {
						motor[BallPicker] = 127;
					}
					else {
						motor[BallPicker] = -127;
					}
				}
				else {
					motor[BallPicker] = 0;
				}
			}
		}

		wait1Msec(trigger_task_loop_time);
	}
}


int launcher_flywheel_running;



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	start_drive = 0.47;

	feeder_state = 0; // 0 is off, 1 is on
	feeder_direction = 1; // 1 is pick-up-balls, -1 is drop balls
	autoload_mode = 0;

	// Gyro Initialization
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in2] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in2] = sensorGyro;
	wait1Msec(2000);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

#define STRAIGHT 0
#define LEFT 1
#define RIGHT 2

void auto_drive(int direction, int speed, int time) {
	switch(direction) {
	case STRAIGHT:
		motor[Drive_L] = speed;
		motor[Drive_R] = speed;
		break;
	case LEFT:
		motor[Drive_L] = -speed;
		motor[Drive_R] = speed;
		break;
	case RIGHT:
		motor[Drive_R] = -speed;
		motor[Drive_L] = speed;
		break;
	}
	wait1Msec(time);
	motor[Drive_R] = 0;
	motor[Drive_L] = 0;
}

void gyro_turn(int angle_delta, int speed){
	int current_angle;
	int target_angle;

	// angle_delta positive value means CounterClockwise
	//             negative value means Clockwise



	current_angle = SensorValue[in2];
	target_angle = abs(current_angle + angle_delta);
	if(angle_delta > 0){
		motor[Drive_L] = -speed;
		motor[Drive_R] = speed;
		} else {
		motor[Drive_R] = -speed;
		motor[Drive_L] = speed;
	}
	while (1)
	{
		current_angle = abs(SensorValue[in2]);
		if (current_angle >= target_angle) {
			break;
		}
		wait1Msec(25);
	}
	motor[Drive_R] = 0;
	motor[Drive_L] = 0;
}

task autonomous()
{
	int autonomous_program;

	// Start the flywheel control task
	startTask( FwControlTask );

	// Start the shooting task
	startTask( CanopyTriggerPID );
	startTask( trigger_management );
	FwVelocitySet( &flywheel, RPM_BACK, start_drive ); // Start Launcher


	autoload_mode = 1;
	set_canopy_position(CANOPY_BACK); // Set Canopy Angle


	// wait1Msec(1500);
	next_auto_shoot_time = nSysTime /*+ 1000*/;

	auto_shoot_mode = 1;


	while (1) {
		if (number_auto_balls_shot >= 4) {
			break;
		}
		wait1Msec(25);
	}

	// Reset count
	number_auto_balls_shot = 0;
	auto_shoot_mode = 0;

	if (SensorValue[AutoProgram] < 1000) {
		autonomous_program = 1;
		} else if (SensorValue[AutoProgram] > 3000) {
		autonomous_program = 2;
		} else {
		autonomous_program = 0;
	}

	switch (autonomous_program) {
	case 1: // Red Squares
		auto_drive(STRAIGHT, 127, 800);
		gyro_turn(-115, 45); // -ve value is clockwise
		auto_drive(STRAIGHT, 64, 3300);
		break;
	case 2: // Blue Squares
		auto_drive(STRAIGHT, 127, 800);
		gyro_turn(155, 45); // +ve value is counterclockwise
		auto_drive(STRAIGHT, 64, 3300);
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	auto_shoot_mode = 0;

	char  str[32];
	int lcd_count = 0;

	start_drive = 0.47;

	feeder_state = 0; // 0 is off, 1 is on
	feeder_direction = 1; // 1 is pick-up-balls, -1 is drop balls
	autoload_mode = 0;

	float turn_scale_factor = 1;

	float ldrive, rdrive;


	bLCDBacklight = true;

	launcher_flywheel_running = 0;

	// Initialize Array of Canopy Angle and Flywheel speed values

	start_speed = RPM_BACK;
	last_canopy_angle = CANOPY_BACK;

	// Start the flywheel control task
	startTask( FwControlTask );

	// Start the shooting task
	startTask( CanopyTriggerPID );
	startTask( trigger_management );

	// Set initial value of Canopy Servo
	//motor[Canopy_servo] = presets[NUM_PRESETS/2][0];

	// default flywheel speed is zero
	FwVelocitySet( &flywheel, 0.0, 0.0 );


	while (true)
	{
		//
		// MAIN JOYSTICK CONTROLS
		//

		// Driver controls

		// If button 7D is pressed, then the turning is slowed down
		if (vexRT[Btn7U] == 1) {
			turn_scale_factor = 0.3;
			} else {
			turn_scale_factor = 1;
		}

		//Normal mode that Aria likes
		ldrive = vexRT[Ch2] + vexRT[Ch1] * turn_scale_factor;
		rdrive = vexRT[Ch2] - vexRT[Ch1] * turn_scale_factor;

		// Straight or turn only experiment for Akshaya
		/*if (abs(vexRT[Ch1]) > abs(vexRT[Ch2])) {
		ldrive = vexRT[Ch1]*turn_scale_factor;
		rdrive = - vexRT[Ch2]*turn_scale_factor;
		} else {
		ldrive = vexRT[Ch2];
		rdrive = vexRT[Ch2];
		} */

		if (abs(ldrive) > 127) { // Scale left and right appropriately if exceeds max
			float temp = 127.0/abs(ldrive);
			ldrive *= temp;
			rdrive *= temp;
		}

		if (abs(rdrive) > 127) {
			float temp = 127.0/abs(rdrive);
			ldrive *= temp;
			rdrive *= temp;
		}

		motor[Drive_L] = ldrive;
		motor[Drive_R] = rdrive;


		// Ball Picker Controls: 5U: forwards, 6U: Backwards, 5D: backwards
		if(vexRT[Btn5D]) {
			wait1Msec(BUTTON_DEBOUNCE_TIME);
			autoload_mode = 1;
			autoload_state = AUTOLOAD_STATE_RELOAD;
		}

		if(vexRT[Btn5U]) {
			autoload_mode = 0;

			feeder_direction = 1;
			feeder_state = 1;
			} else if( vexRT[Btn6U]) {
			autoload_mode = 0;
			feeder_direction = -1;
			feeder_state = 1;
			} else {
			feeder_state = 0;
		}

		//
		// *** Lift Controls ***
		//

		// 6D is a dead man's switch
		// controlled by ch3, checks for limit at top and bottom

		if(vexRT[Ch3] >= 30 && /*SensorValue(LiftTop) == 0*/ vexRT[ Btn6D ])
		{
			motor[Lift1] = 127;
			motor[Lift2] = 127;
		}

		else if(vexRT[Ch3] <= -30 /*&& SensorValue(LiftBottom) == 0*/ && vexRT[ Btn6D ])
		{
			motor[Lift1] = -127;
			motor[Lift2] = -127;
		}

		else
		{
			motor[Lift1] = 0;
			motor[Lift2] = 0;
		}


		//
		// Partner Joystick Controls
		//

		// Launcher: Presets START the launcher; 5U turns it off
		//           8U: Fast
		//           8R: Medium
		//           8D: Sl
		//           5U: Turn Flywheel on and set Canopy to last values
		//           6D: Turn Flywheel off
		if (vexRT[Btn8UXmtr2]) {
			set_canopy_position(CANOPY_BACK);
			FwVelocitySet( &flywheel, RPM_BACK, start_drive );
			launcher_flywheel_running = 1;
		}
		else if (vexRT[Btn8RXmtr2]) {
			set_canopy_position(CANOPY_MIDDLE);
			FwVelocitySet( &flywheel, RPM_MIDDLE, start_drive );
			launcher_flywheel_running = 1;
		}
		else if (vexRT[Btn8DXmtr2]) {
			set_canopy_position(CANOPY_FRONT);
			FwVelocitySet( &flywheel, RPM_FRONT, start_drive );
			launcher_flywheel_running = 1;
		}
		else if (vexRT[Btn5UXmtr2]) {
			set_canopy_position(last_canopy_angle);
			FwVelocitySet( &flywheel, start_speed, start_drive );
			launcher_flywheel_running = 1;
		}
		else if(vexRT[ Btn6DXmtr2 ]) {
			start_speed = flywheel.target;
			start_drive = flywheel.drive;
			last_canopy_angle = PIDs[PID_CANOPY].desired_position;
			FwVelocitySet( &flywheel, 0.0, 0.0 );
			launcher_flywheel_running = 0;
		}

		// Launcher Flywheel Increment / Decrement
		//
		// Increase Flywheel Speed: 7R
		// Decrease Flywheel Speed: 7L
		if (launcher_flywheel_running) {
			if (vexRT[Btn7RXmtr2]) {
				if( flywheel.target + FLYWHEEL_SPEED_DELTA_STEP <= FLYWHEEL_MAX_SPEED){
					wait1Msec(BUTTON_DEBOUNCE_TIME);
					FwVelocitySet( &flywheel, flywheel.target+FLYWHEEL_SPEED_DELTA_STEP, flywheel.drive+0.02 );
				}
			}
			else if (vexRT[Btn7LXmtr2]) {
				if( flywheel.target - FLYWHEEL_SPEED_DELTA_STEP >= FLYWHEEL_MIN_SPEED)
				{
					wait1Msec(BUTTON_DEBOUNCE_TIME);
					FwVelocitySet( &flywheel, flywheel.target-FLYWHEEL_SPEED_DELTA_STEP, flywheel.drive-0.02 );
				}
			}
		}

		// Canopy Increment/Decrement
		// 7U: Increment
		// 7D: Decrement

		if (vexRT[ Btn7UXmtr2 ] == 1)
		{
			wait1Msec(BUTTON_DEBOUNCE_TIME);
			set_canopy_position(PIDs[PID_CANOPY].desired_position + CANOPY_INCREMENT);
		}
		else if (vexRT[ Btn7DXmtr2 ] == 1)
		{
			wait1Msec(BUTTON_DEBOUNCE_TIME);
			set_canopy_position(PIDs[PID_CANOPY].desired_position - CANOPY_INCREMENT);
		}


		/*

		// Trigger Increment/Decrement
		// Debugging ONLY
		//      8L: Increment
		//      6D: Decrement
		if (vexRT[ Btn8LXmtr2 ] == 1){
		wait1Msec(BUTTON_DEBOUNCE_TIME);
		set_trigger_position(PIDs[PID_TRIGGER].desired_position + 10);
		}
		else if (vexRT[ Btn6DXmtr2 ] == 1) {
		wait1Msec(BUTTON_DEBOUNCE_TIME);
		set_trigger_position(PIDs[PID_TRIGGER].desired_position - 10);
		} */

		// Nudge Robot Angle Left or Right
		// Joystick 1 (on partner's joystick) -- actual nudge done in asynchronous task
		//if (vexRT[Ch1Xmtr2] > 30) nudge_right_request = 1;
		//if (vexRT[Ch1Xmtr2] < -30) nudge_left_request = 1;

		// SHOOT!
		// Button 6U
		if (vexRT[Btn6UXmtr2]) {
			// wait1Msec(BUTTON_DEBOUNCE_TIME); this wait may not be needed for shooting
			shoot_request = 1;
		}

		wait1Msec(25);

		lcd_count++;

		if (lcd_count % 20 == 0) { // update only 2 time per second (to prevent control lag)
			// Display useful things on the LCD
			sprintf( str, "%4d %4d  %5.2f", flywheel.target,  flywheel.current, nImmediateBatteryLevel/1000.0 );
			displayLCDString(0, 0, str );
			sprintf( str, "%5.2f %3d %3d ", flywheel.error, flywheel.motor_drive, PIDs[PID_CANOPY].desired_position); // change back to canopy_servo_value
			// sprintf( str, "%3d %3d %3.2f ", flywheel.motor_drive, PIDs[PID_CANOPY].desired_position, trigger_servo_value ); // change back to canopy_servo_value
			displayLCDString(1, 0, str );
		}
	}
}
